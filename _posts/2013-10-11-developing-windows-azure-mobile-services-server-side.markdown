---
layout: post
title: "Developing Windows Azure Mobile Services server-side"
date: 2013-10-11 08:30:00 +0100
comments: true
published: true
categories: ["post"]
tags: ["CSharp", "General", "JavaScript", "Software", "Source control", "Azure"]
alias: ["/post/2013/10/11/Developing-Windows-Azure-Mobile-Services-server-side.aspx", "/post/2013/10/11/developing-windows-azure-mobile-services-server-side.aspx"]
author: Maarten Balliauw
redirect_from:
 - /post/2013/10/11/Developing-Windows-Azure-Mobile-Services-server-side.aspx.html
 - /post/2013/10/11/developing-windows-azure-mobile-services-server-side.aspx.html
---
<p><em>Word of warning: This is a partial cross-post from the </em><a href="http://blog.jetbrains.com/webstorm/"><em>JetBrains WebStorm blog</em></a><em>. The post you are currently reading adds some more information around Windows Azure Mobile Services and builds on a full example and is a bit more in-depth.</em></p>  <p>With Microsoft’s <a href="http://www.windowsazure.com/en-us/develop/mobile/">Windows Azure Mobile Services</a>, we can build a back-end for iOS, Android, HTML, Windows Phone and Windows 8 apps that supports storing data, authentication, push notifications across all platforms and more. There are <a href="http://www.windowsazure.com/en-us/develop/mobile/tutorials/get-started/">client libraries</a> available for all these platforms which can be used when developing in an IDE of choice, e.g. <a href="http://www.jetbrains.com/objc/">AppCode</a>, <a href="http://developer.android.com/sdk/installing/studio.html">Google Android Studio</a> or <a href="http://www.visualstudio.com">Visual Studio</a>. In this post, let’s focus on what these different platforms have in common: the server-side code.</p>  <p>This post was sparked by my buddy <a href="http://azug.be/2013-09-26---going-mobile-with-windows-azure-mobile-services-video">Kristof Rennen</a>’s session for <a href="http://www.azug.be">our user group</a>. During his session he mentioned a couple of times how he dislikes Node.js and the trial-and-error manner of building the server-side due to lack of good tooling. Working for a <a href="http://www.jetbrains.com">tooling vendor</a> and intrigued by the quest of finding a better way, I decided to post the short article you are currently reading.</p>  <p>Do note that I will focus more on how to get your development environment set-up and less on the Windows Azure Mobile Services feature set. Yes, you <em>will</em> learn some of the very basics but there are <a href="http://www.thejoyofcode.com/The_twelve_days_of_ZUMO.aspx">way better resources available</a> for getting in-depth knowledge on the topic.</p>  <p>Here’s what we will see in this post:</p>  <ul>   <li>Setting up a Windows Azure Mobile Service </li>    <li>Creating a table and storing data </li>    <li>A simple HTML/JS client </li>    <li>Adding logic to our API </li>    <li>Working on server-side logic with WebStorm </li>    <li>Sending e-mail using an Node.js module </li>    <li>Putting our API to the test with the REST client </li>    <li>Unit testing our logic </li> </ul>  <h2><a name="h.ngq0jde8fwyr"></a>The scenario</h2>  <p>Doing some exploration is always more fun when we can do it based on a simple scenario. Whenever JetBrains goes to a conference and we have a booth, we like to do a raffle for licenses. The idea is simple: come to our booth for a chat, fill out a simple form and we will pick random names after the conference and send a free license.</p>  <p>For this post, I’ve created a very simple form in HTML and JavaScript, collecting visitor name and e-mail address.</p>  <p><a href="/images/1_2.png"><img title="1" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="1" src="/images/1_thumb_2.png" width="526" height="558" /></a></p>  <p>Once someone participates in the raffle, the name and e-mail address are stored in a database and we send out an e-mail thanking that person for visiting the booth together with a link to download a product trial.</p>  <h2>Setting up a Windows Azure Mobile Service</h2>  <p>First things first: we will require a <a href="http://www.windowsazure.com/en-us/pricing/free-trial/">Windows Azure account</a> to start developing. Next, we can create a new Mobile Service through the Windows Azure <a href="https://manage.windowsazure.com">Management Portal</a>.</p>  <p><a href="/images/2_1.png"><img title="2" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="2" src="/images/2_thumb_1.png" width="719" height="250" /></a></p>  <p>Next, we can give our service a name and pick the datacenter location for it. We also have to provide the type of database we want to use: a free, 20 MB database, or a full-fledged SQL Database. While Windows Azure Mobile Services is always coupled to a database, we can build a custom API with it as well.</p>  <p><a href="/images/3_1.png"><img title="3" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="3" src="/images/3_thumb_1.png" width="678" height="446" /></a></p>  <p>Once completed, we get several tabs to work with. There’s the initial welcome screen, displaying links to documentation and client libraries. The other tabs give access to monitoring, scaling, how we want to authenticate users, push notification settings and logs. Since we want to store data of booth visitors, let’s enter the <em>Data</em> tab.</p>  <h2><a name="h.k8wij3yja2zo"></a>Creating a table and storing data</h2>  <p>From the <em>Data</em> tab, we can create a new table. Let’s call it <em>Visitor</em>. When creating a new table, we have to specify access rules for the API that will be available on top of it.</p>  <p><a href="/images/4_1.png"><img title="4" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="4" src="/images/4_thumb_1.png" width="647" height="557" /></a></p>  <p>We can tell who can read (API GET request), insert (API POST request), update (API PATCH request) and delete (API DELETE request). Since our application will only insert new data and we don’t want to force booth visitors to log in with their social profiles, we can specify inserts can be done if an API key is provided. All other operations will be blocked for outside users: reading and deleting will only be available through the Windows Azure Management Portal with the above settings.</p>  <p>Do we have to create columns for storing booth visitor data? By default, Windows Azure Mobile Services has “dynamic schema” enabled which means we can throw some JSON at our Mobile Service it and it will store data for us.</p>  <h2><a name="h.samtm7qpf0l1"></a>A simple HTML/JS client</h2>  <p>As promised earlier in this post, let’s see how we can build a simple client for the service we have just created. We’ll go with an HTML and JavaScript based client as it’s fairly easy to demonstrate. Again, have a look at <a href="http://www.windowsazure.com/en-us/develop/mobile/tutorials/get-started/">other client SDK’s</a> for the platform you are developing for.</p>  <p>Our HTML page exists of nothing but two text boxes and a button, conveniently named <em>name</em>, <em>email</em> and <em>send</em>. There are two ways of sending data to our Mobile Service: calling the API directly or making use of the client library provided. Both are easy to do: the API lives at <em>https://&lt;servicename&gt;.azure-mobile.net/tables/</em>&lt;tablename&gt; and we can POST a JSON-serialized object to it, an approach we’ll take later in this blog post. There is also a JavaScript client library available from <em>https://&lt;servicename&gt;.azure-mobile.net/client/MobileServices.Web-1.0.0.min.js</em> which our client is using.</p>  <p><a href="/images/5_1.png"><img title="5" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="5" src="/images/5_thumb_1.png" width="434" height="391" /></a></p>  <p>As we can see, a new <em>MobileServiceClient </em>is created on which we can get a table reference (<em>getTable</em>) and insert a JSON-formatted object. Do note that we have to pass in an API key in the client constructor, which can be obtained from the Windows Azure Management Portal under the <em>Manage Keys</em> toolbar button.</p>  <p>From the portal, we can now see the data we’re submitting from our simple application:</p>  <p><a href="/images/6.png"><img title="6" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="6" src="/images/6_thumb_1.png" width="473" height="157" /></a></p>  <h2><a name="h.7fcqnyr38t6"></a>Adding logic to our API</h2>  <p>Let’s make it a bit more exciting! What if we wanted to store a timestamp with every record? We may want to have some insight into when our booth was busiest. We can send a timestamp from the client but that would only add clutter to our client-side code. Also if we wanted to port the HTML/JS client to other platforms it would mean we have to make sure every client sends this data to our mobile service. In short: this calls for some server-side logic.</p>  <p>For every table created, we can make use of the <em>Script</em> tab to add custom logic to read, insert, update and delete operations which we can write in JavaScript. By default, this is what a script for insert may look like:</p>  <p><a href="/images/7_1.png"><img title="7" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="7" src="/images/7_thumb_1.png" width="361" height="204" /></a></p>  <p>The <em>insert </em>function will be called with 3 parameters: the item to be stored (our JSON-serialized object), the current user and the full request. By default, the <em>request.execute()</em> function is called which will make use of the other two parameters internally. Let’s enrich our item with a timestamp.</p>  <p><a href="/images/8_1.png"><img title="8" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="8" src="/images/8_thumb_1.png" width="361" height="234" /></a></p>  <p>Hitting <em>Save</em> will deploy this script to our mobile service which from now on will store an inserted timestamp in our database as well.</p>  <p>This is a very trivial example. There are a lot of things that can be done server-side: enforcing validation, record filtering, storing data in other tables as well, sending e-mail or text messages, … Here’s <a href="http://chrisrisner.com/Common-Scenarios-with-Windows-Azure-Mobile-Services">a post</a> with some common scenarios. <a href="http://msdn.microsoft.com/en-us/library/windowsazure/jj554226.aspx">Full reference</a> to the server-side objects is also available.</p>  <h2><a name="h.cocp5dwgnx7k"></a>Working on server-side logic with WebStorm</h2>  <p>Unfortunately, the in-browser editor for server-side scripts is a bit limited. It features no autocompletion and all code has to go in one file. How would we create shared logic which can be re-used across different scripts? How would we unit test our code? This is where WebStorm comes in. We can access the complete server-side code through a Git repository and work on it in a full IDE!</p>  <p>The Git access to our mobile service is disabled by default. Through the portal’s right-hand side menu, we can enable it by clicking the <em>Set up source control</em> link. Next, we can find repository details from the <em>Configure</em> tab.</p>  <p><a href="/images/9_1.png"><img title="9" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="9" src="/images/9_thumb_1.png" width="586" height="566" /></a></p>  <p>We can now use WebStorm’s <strong><em>VCS | Checkout From Version Control | Git</em></strong> menu to bring down the server-side code for our Windows Azure Mobile Service.</p>  <p><a href="/images/10_1.png"><img title="10" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="10" src="/images/10_thumb_1.png" width="606" height="181" /></a></p>  <p>In our project, we can see several folders and files. The <em>service/api</em> folder can hold custom API’s (check the <em>readme.md</em> file for more info). <em>service/scheduler</em> can hold scripts that execute at a given time or interval, much like CRON jobs. <em>service/shared</em> can hold shared scripts that can be used inside table logic, custom API’s and scheduler scripts. In the <em>service/table</em> folder we can find the script we have created through the portal: <em>visitor.insert.js</em>. Also note the <em>visitor.json</em> file which contains the access rules we configured through the portal earlier.</p>  <p><a href="/images/11.png"><img title="11" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="11" src="/images/11_thumb.png" width="700" height="314" /></a></p>  <p>From now on, we can work inside WebStorm and push to the remote Git repository if we want to deploy our new code.</p>  <h2><a name="h.j9accqs9jd36"></a>Sending e-mail using a Node.js module</h2>  <p>Let’s go back to our initial requirements: whenever someone enters their name and e-mail address in our application, we want to send out an e-mail thanking them for participating. We can do this by making use of an NPM module, for example <a href="https://npmjs.org/package/sendgrid">SendGrid</a>.</p>  <p>Windows Azure Mobile Services comes with some NPM modules preinstalled, like <a href="https://npmjs.org/package/sendgrid">SendGrid</a> and <a href="http://www.windowsazure.com/en-us/develop/mobile/tutorials/twilio-for-voice-and-sms/">Twilio</a>. However we want to make sure we are always using the same version of the NPM package, so let’s install it into our project. WebStorm has a built-in package manager to do this, however Windows Azure Mobile Services requires us to install the module in a non-standard location (the <em>service </em>folder) hence we will use the <em>Terminal</em> tool window to install it.</p>  <p><a href="/images/12.png"><img title="12" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="12" src="/images/12_thumb.png" width="568" height="272" /></a></p>  <p>Once finished, we can start working on our e-mail logic. Since we may want to re-use the e-mail logic (and we want to unit test it later), it’s best to create our logic in the <em>shared</em> folder.</p>  <p><a href="/images/13.png"><img title="13" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="13" src="/images/13_thumb.png" width="612" height="521" /></a></p>  <p>In our shared module, we can make use of the SendGrid module to create and send an e-mail. We can export our <em>sendThankYouMessage</em> function to consumers of our shared module. In the <em>visitor.insert.js</em> script we can require our shared module and make use of the functionality it exposes. And as an added bonus, WebStorm provides us with autocompletion, code analysis and so on.</p>  <p><a href="/images/14.png"><img title="14" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="14" src="/images/14_thumb.png" width="539" height="109" /></a></p>  <p>Once we’ve updated our code, we can transfer our server-side code to Windows Azure Mobile Services. <strong><em>Ctrl+K</em></strong> (or <strong><em>Cmd+K on Mac OS X</em></strong>) allows us to commit and push from within the IDE.</p>  <p><a href="/images/15.png"><img title="15" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="15" src="/images/15_thumb.png" width="567" height="481" /></a></p>  <h2><a name="h.2wxnw578w1zl"></a>Putting our API to the test with the REST client</h2>  <p>Once our changes have been deployed, we can test our API. This can be done using one of the client libraries or by making use of WebStorm’s built-in REST client. From the <strong><em>Tools | Test RESTful Web Service</em></strong> menu we can craft our API calls manually.</p>  <p>We can specify the HTTP method to use (POST since we want to insert) and the URL to our Windows Azure Mobile Services endpoint. In the headers section, we can add a <em>Content-Type</em> header and set it to <em>application/json</em>. We also have to specify an API key in the <em>X-ZUMO-APPLICATION</em> header. This API key can be found in the Windows Azure Management Portal. On the right-hand side we can provide the text to post, in this case a JSON-serialized object with some properties.</p>  <p><a href="/images/16.png"><img title="16" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="16" src="/images/16_thumb.png" width="640" height="295" /></a></p>  <p>After running the request, we get back response headers and a response body:</p>  <p><a href="/images/17_2.png"><img title="17" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="17" src="/images/17_thumb_2.png" width="640" height="148" /></a></p>  <p>No error message but an object is being returned? Great, that means our code works (and should also be sending out an e-mail). If something does go wrong, the <em>Logs</em> tab in the Windows Azure portal can be a tremendous help in finding out what went wrong.</p>  <p>Through the toolbar on the left, we can export/import requests, making it easy to create a number of predefined requests that can easily be run over and over for testing the REST API.</p>  <h2><a name="h.jsmhrky49c8i"></a>Unit testing our logic</h2>  <p>With WebStorm we can easily test our JavaScript code and custom Node.js modules. Let’s first set up our IDE. Unit testing can be done using the<a href="https://npmjs.org/package/nodeunit">nodeunit</a> testing framework which we can install using the Node.js package manager.</p>  <p><a href="/images/18_2.png"><img title="18" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="18" src="/images/18_thumb_2.png" width="630" height="671" /></a></p>  <p>Next, we can create a new Run Configuration from the toolbar selecting <em>Nodeunit</em> as the configuration type and entering all required configuration details. In our case, let’s run all tests from the <em>test</em> directory.</p>  <p><a href="/images/19_1.png"><img title="19" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="19" src="/images/19_thumb_1.png" width="614" height="381" /></a></p>  <p>Next, we can create a folder that will hold our tests and mark it as a Test Source Root (open the context menu and use <strong><em>Mark Directory As | Test Source Root</em></strong>). Tests for Nodeunit are always considered modules and should export their test functions. Here’s a very basic example which tells Nodeunit to wait for one assertion, assert that a boolean is true and marks the test case completed.</p>  <p><a href="/images/20.png"><img title="20" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="20" src="/images/20_thumb.png" width="305" height="186" /></a></p>  <p>Of course we can also test our business logic. It’s best to create separate modules under the <em>shared</em> folder as they will be easier to unit test. However if you do have to test the actual table scripts (like <em>insert</em> functionality), there is a little trick that allows doing just that. The following snippet exports the insert function outside of the table-specific module:</p>  <p><a href="/images/21.png"><img title="21" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="21" src="/images/21_thumb.png" width="260" height="53" /></a></p>  <p>We can now test the complete <em>visitor.insert.js</em> module and even provide mocks to work with. The following example loads all our modules and sets up test expectation. We’re also overriding specific functionalities such as the <em>sendThankYouMessage </em>function to just make sure it’s called by our table API logic.</p>  <p><a href="/images/22_1.png"><img title="22" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="22" src="/images/22_thumb_1.png" width="542" height="441" /></a></p>  <p>The full source code for both the server-side and client-side application can be found on<a href="https://github.com/maartenba/JetBrainsBoothMobileService">https://github.com/maartenba/JetBrainsBoothMobileService</a>.</p>  <p>If you would like to learn more about Windows Azure Mobile Services and work with authentication, push notifications or custom API’s checkout the <a href="http://www.windowsazure.com/en-us/develop/mobile/">getting started documentation</a>. And if you haven’t already, give <a href="http://www.jetbrains.com/webstorm">WebStorm</a> a try.</p>  <p>Enjoy!</p>
{% include imported_disclaimer.html %}
