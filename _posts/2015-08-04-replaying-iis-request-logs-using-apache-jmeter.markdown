---
layout: post
title: "Replaying IIS request logs using Apache JMeter"
date: 2015-08-04 11:19:00 +0000
comments: true
published: true
categories: ["post"]
tags: ["ASP.NET", "CSharp", "ICT", "Profiling", "Software", "Webfarm", "Windows Azure"]
alias: ["/post/2015/08/04/Replaying-IIS-request-logs-using-Apache-JMeter.aspx", "/post/2015/08/04/replaying-iis-request-logs-using-apache-jmeter.aspx"]
author: Maarten Balliauw
redirect_from:
 - /post/2015/08/04/Replaying-IIS-request-logs-using-Apache-JMeter.aspx.html
 - /post/2015/08/04/replaying-iis-request-logs-using-apache-jmeter.aspx.html
---
<p><img width="200" height="251" title="I don't always test code..." align="right" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; float: right; padding-top: 0px; padding-left: 0px; border-left: 0px; margin: 0px 0px 5px 5px; display: inline; padding-right: 0px" alt="I don't always test code..." src="http://s2.quickmeme.com/img/d6/d689b760f2debdb9d4cad9b7f755f8113d041875f98d7f2e8f1a755e6dc239ed.jpg" border="0">How would you validate a new API is compatible with an old API? While upgrading frameworks in a web application we’re building, that was exactly the question we were asking ourselves. Sure, we could write synthetic tests on each endpoint, but is that representative? Users typically find <strike>insane</strike> better ways to test an API, so why not replay actual requests against the new API?</p> <p>In this post, we’ll see how we can do exactly this using IIS and <a href="http://jmeter.apache.org/">Apache JMeter</a>. I’ve been using JMeter quite often in the past years doing web development, as it’s one of the most customizable load test and functional test tools for web applications. The interface is quite spartan, but don’t let that discourage you from using JMeter. After all, this <em>is</em> Sparta!</p> <h2>Collecting IIS logs</h2> <p>Of course, one of the first things to do before being able to replay actual request logs is collecting those logs. Depending on the server configuration, these can be stored in many locations, such as <em>C:\inetpub\logs\LogFiles</em> or <em>C:\Windows\system32\LogFiles\W3SVC1</em>. I will leave it up to you where to find them.</p> <p>In our case, we’re using Azure Cloud Services to host our web applications. IIS logs are stored in a location similar to <em>C:\Resources\Directory\&lt;deploymentid&gt;.&lt;solename&gt;.DiagnosticStore\LogFiles\Web\W3SVC&lt;numbers&gt;</em>. If you’d be on Azure Web Sites, logs <a href="https://azure.microsoft.com/en-us/documentation/articles/web-sites-enable-diagnostic-log/">must be enabled first</a> before they can be downloaded.</p> <h2></h2> <h2>Converting IIS logs</h2> <p>By default, IIS logs are in the <a href="http://www.w3.org/TR/WD-logfile.html">W3C-IIS format</a>. Which is great, as many tools are able to parse that format. Except for JMeter,which works with <a href="https://en.wikipedia.org/wiki/Common_Log_Format">NCSA Common Log Format</a>. Not to worry though! Fetch the <a href="http://www.rebex.net/rconvlog/">RConvLog</a> tool and invoke it on the IIS log file that should be replayed later on.</p> <p><a href="/images/image_353.png"><img title="Running RConvLog" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" alt="Running RConvLog" src="/images/image_thumb_313.png" border="0"></a></p> <p>We’re running RConvLog on our log, which will be converted to the NCSA log format. We’re also providing RConvLog with an idea about the time zone the logs were generated in. Since Azure runs in UTC, we can just tell it it’s all UTC by passing in <em>+0000</em>.</p> <h2>Setting up a JMeter test plan</h2> <p>Time for action! After launching JMeter, we can start setting up our test plan. Using the context <strong><em>Add | Threads | Thread Group </em></strong>menu, we can add a thread group. A thread group in JMeter is what simulates users. We can decide how many users are active at the same time (number of threads), how dispersed requests are (ramp-up period) and how many requests will be made in total (loop count * number of threads). The following configuration will simulate 10.000 requests with at most 100 concurrent users. Note that when replaying logs, having 10.000 requests means only the first 10.000 requests from the log will be replayed (if in the next step, the <i>OrderPreservingLogParser</i> is selected). If the log file holds 40.000 and we want to replay them all, we’ll have to do the math and ensure we actually will do that number of requests.</p> <p><a href="/images/image_354.png"><img title="JMeter test plan - users and threads" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" alt="JMeter test plan - users and threads" src="/images/image_thumb_314.png" border="0"></a></p> <p>Yes, spartan. I already mentioned that. Next up, we can use the <strong><em>Add | Sampler | Access Log Sampler</em></strong> context menu. We can now specify where our log file that is to be replayed lives. Since NCSA log files don’t hold the hostname or server port, we can configure them here. For example if we want to replay logs against <em>localhost</em>, that’s what we’d enter under <em>Server</em>. We’ll also have to enter the log file location so that JMeter knows which log file to read from.</p> <p>Important thing to change here! The log parser class. JMeter comes with several of them and can be extended with custom classes as well. The three that come in the box are the <em>TCLogParser</em> which processes the access log independently for each thread. The <em>SharedTCLogParser</em> and <em>OrderPreservingLogParser</em> share access to the file, where each thread gets the next entry in the log. Let’s pick the <em>OrderPreservingLogParser</em> so that the access log is read and replayed line by line.</p> <p><a href="/images/image_355.png"><img title="JMeter Access Logs Sampler" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" alt="JMeter Access Logs Sampler" src="/images/image_thumb_315.png" border="0"></a></p> <p>All that’s left is using the <strong><em>Add | Listener | Aggregate Report</em></strong> context menu so that we can have a look at the results. That’s pretty much it. We should now save our test plan so we can run JMeter.</p> <h2></h2> <h2>Replaying the logs with JMeter</h2> <p>Clicking the green <strong><em>Run</em> </strong>button launches our virtual users and processes logs. The <em>Aggregate Report</em> will list every request made, show its timings and the error rate.</p> <p><a href="/images/image_356.png"><img title="Aggregate Report when replaying IIS request logs" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" alt="Aggregate Report when replaying IIS request logs" src="/images/image_thumb_316.png" border="0"></a></p> <p>That’s about it. But there are some considerations to make…</p> <h2>Considerations</h2> <p>What have we tested so far? Not a lot, to be honest. We’ve replayed IIS request logs but have not validated they return the expected results. So… how to do that? Using the <strong><em>Add | Assertions</em></strong> context menu, we can add assertions on status code and response contents. That’s great for functional tests, but replaying 100.000 entries is a bit harder to validate… For the test case we’ve opened this blog post with, we’ve created an Excel file that has the HTTP status codes and response size (they are in the logs) and compare them with the results we see in JMeter.</p> <p>Maybe we’re not interested in the actual result, but in what is going on in our application? Turns out replaying IIS request logs can help us there, to. For the application we’re converting, we’re using <a href="https://azure.microsoft.com/en-us/documentation/articles/app-insights-get-started/">Azure AppInsights</a> to collect real-time telemetry from our application.&nbsp; We could also use a profiler like <a href="http://www.jetbrains.com">JetBrains’ dotMemory and dotTrace</a>, we can subject our running application to close inspection while JMeter simulates a real load against it.</p><p>And of course, we're testing only anonymous GET requests here. While JMeter supports sending cookies and request types other than GET, there are other tools to test those scenarios as well, like <a href="http://www.telerik.com/fiddler" target="_blank">Fiddler</a> or <a href="http://www.runscope.com" target="_blank">Runscope</a>.</p> <p>Enjoy!</p>
{% include imported_disclaimer.html %}
