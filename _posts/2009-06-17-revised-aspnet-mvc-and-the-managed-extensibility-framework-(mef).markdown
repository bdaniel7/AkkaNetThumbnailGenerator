---
layout: post
title: "Revised: ASP.NET MVC and the Managed Extensibility Framework (MEF)"
date: 2009-06-17 10:09:00 +0000
comments: true
published: true
categories: ["post"]
tags: ["ASP.NET", "CSharp", "Debugging", "General", "MEF", "MVC", "Personal"]
alias: ["/post/2009/06/17/Revised-ASPNET-MVC-and-the-Managed-Extensibility-Framework-(MEF).aspx", "/post/2009/06/17/revised-aspnet-mvc-and-the-managed-extensibility-framework-(mef).aspx"]
author: Maarten Balliauw
redirect_from:
 - /post/2009/06/17/Revised-ASPNET-MVC-and-the-Managed-Extensibility-Framework-(MEF).aspx.html
 - /post/2009/06/17/revised-aspnet-mvc-and-the-managed-extensibility-framework-(mef).aspx.html
---
<p>A while ago, I did a <a href="/post/2009/04/21/ASPNET-MVC-and-the-Managed-Extensibility-Framework-(MEF).aspx" target="_blank">blog post on combining ASP.NET MVC and MEF (Managed Extensibility Framework)</a>, making it possible to &ldquo;plug&rdquo; controllers and views into your application as a module. I received a lot of positive feedback as well as a hard question from <a href="http://www.danswatik.com/" target="_blank">Dan Swatik</a> who was experiencing a Server Error with this approach&hellip; Here&rsquo;s a better approach to ASP.NET MVC and MEF.</p>
<p><a href="http://www.dotnetkicks.com/kick/?url=/post/2009/06/17/Revised-ASPNET-MVC-and-the-Managed-Extensibility-Framework-(MEF).aspx&amp;title=Revised: ASP.NET MVC and the Managed Extensibility Framework (MEF)"><img src="http://www.dotnetkicks.com/Services/Images/KickItImageGenerator.ashx?url=/post/2009/06/17/Revised-ASPNET-MVC-and-the-Managed-Extensibility-Framework-(MEF).aspx" border="0" alt="kick it on DotNetKicks.com" /> </a></p>
<h2>The Exception</h2>
<p><a href="/images/servererror.png"><img style="border-bottom: 0px; border-left: 0px; display: block; float: none; margin-left: auto; border-top: 0px; margin-right: auto; border-right: 0px" title="Server Error" src="/images/servererror_thumb.png" border="0" alt="Server Error" width="644" height="310" /></a></p>
<p>The stack trace was being quite verbose on this one:</p>

<blockquote>
<p><span style="font-family: courier new,courier;"><strong>InvalidOperationException</strong><br /><br />The view at '~/Plugins/Views/Demo/Index.aspx' must derive from ViewPage, ViewPage&lt;TViewData&gt;, ViewUserControl, or ViewUserControl&lt;TViewData&gt;. <br /><br />at System.Web.Mvc.WebFormView.Render(ViewContext viewContext, TextWriter writer) at System.Web.Mvc.ViewResultBase.ExecuteResult(ControllerContext context) at System.Web.Mvc.ControllerActionInvoker.InvokeActionResult(ControllerContext controllerContext, ActionResult actionResult) at System.Web.Mvc.ControllerActionInvoker.&lt;&gt;c__DisplayClass11.&lt;InvokeActionResultWithFilters&gt;b__e() at System.Web.Mvc.ControllerActionInvoker.InvokeActionResultFilter(IResultFilter filter, ResultExecutingContext preContext, Func`1 continuation) at System.Web.Mvc.ControllerActionInvoker.&lt;&gt;c__DisplayClass11.&lt;&gt;c__DisplayClass13.&lt;InvokeActionResultWithFilters&gt;b__10() at System.Web.Mvc.ControllerActionInvoker.InvokeActionResultWithFilters(ControllerContext controllerContext, IList`1 filters, ActionResult actionResult) at System.Web.Mvc.ControllerActionInvoker.InvokeAction(ControllerContext controllerContext, String actionName) at System.Web.Mvc.Controller.ExecuteCore() at System.Web.Mvc.ControllerBase.Execute(RequestContext requestContext) at System.Web.Mvc.ControllerBase.System.Web.Mvc.IController.Execute(RequestContext requestContext) at System.Web.Mvc.MvcHandler.ProcessRequest(HttpContextBase httpContext) at System.Web.Mvc.MvcHandler.ProcessRequest(HttpContext httpContext) at System.Web.Mvc.MvcHandler.System.Web.IHttpHandler.ProcessRequest(HttpContext httpContext) at System.Web.HttpApplication.CallHandlerExecutionStep.System.Web.HttpApplication.IExecutionStep.Execute() at System.Web.HttpApplication.ExecuteStep(IExecutionStep step, Boolean&amp; completedSynchronously)</span></p>

</blockquote>

<p>Our exception seemed to be thrown ONLY when the following conditions were met:</p>
<ul>
<li>The View was NOT located in ~/Views but in ~/Plugins/Views (or other path)</li>
<li>The View created in our MEF plugin was strong-typed</li>
</ul>
<h2>Problem one&hellip; Forgot to register ViewTypeParserFilter&hellip;</h2>
<p>Allright, go calling me stupid&hellip; Our ~/Plugins/Views folder was not containing the following Web.config file:</p>
<p>[code:c#]</p>
<p>&lt;?xml version="1.0"?&gt; <br />&lt;configuration&gt; <br />&nbsp; &lt;system.web&gt; <br />&nbsp;&nbsp;&nbsp; &lt;httpHandlers&gt; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;add path="*" verb="*" <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type="System.Web.HttpNotFoundHandler"/&gt; <br />&nbsp;&nbsp;&nbsp; &lt;/httpHandlers&gt;</p>
<p>&nbsp;&nbsp;&nbsp; &lt;!-- <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Enabling request validation in view pages would cause validation to occur <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; after the input has already been processed by the controller. By default <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MVC performs request validation before a controller processes the input. <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; To change this behavior apply the ValidateInputAttribute to a <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; controller or action. <br />&nbsp;&nbsp;&nbsp; --&gt; <br />&nbsp;&nbsp;&nbsp; &lt;pages <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validateRequest="false" <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pageParserFilterType="System.Web.Mvc.ViewTypeParserFilter, System.Web.Mvc, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35" <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pageBaseType="System.Web.Mvc.ViewPage, System.Web.Mvc, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35" <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; userControlBaseType="System.Web.Mvc.ViewUserControl, System.Web.Mvc, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35"&gt; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;controls&gt; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;add assembly="System.Web.Mvc, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35" namespace="System.Web.Mvc" tagPrefix="mvc" /&gt; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/controls&gt; <br />&nbsp;&nbsp;&nbsp; &lt;/pages&gt; <br />&nbsp; &lt;/system.web&gt;</p>
<p>&nbsp; &lt;system.webServer&gt; <br />&nbsp;&nbsp;&nbsp; &lt;validation validateIntegratedModeConfiguration="false"/&gt; <br />&nbsp;&nbsp;&nbsp; &lt;handlers&gt; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;remove name="BlockViewHandler"/&gt; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;add name="BlockViewHandler" path="*" verb="*" preCondition="integratedMode" type="System.Web.HttpNotFoundHandler"/&gt; <br />&nbsp;&nbsp;&nbsp; &lt;/handlers&gt; <br />&nbsp; &lt;/system.webServer&gt; <br />&lt;/configuration&gt;</p>
<p>[/code]</p>
<p>Now why would you need this one anyway? Well: first of all, you do not want your views to expose their source code. Therefore, we add the <em>HttpNotFoundHandler</em> for this folder. Next, we do not want request validation to happen again (because this is already done when invoking the controller). Next: we want the <em>MvcViewTypeParserFilter</em> to be used for enabling strong-typed views (more on this by <a href="http://haacked.com/archive/2009/05/05/page-view-lockdown.aspx" target="_blank">Phil Haack</a>).</p>
<h2>Problem two: MEF&rsquo;s approach to plugins and ASP.NET&rsquo;s approach to rendering views&hellip;</h2>
<p>When compiling a view, ASP.NET dynamically compiles the markup into a temporary assembly, after which it is rendered. This compilation process knows only the assemblies loaded by your web application&rsquo;s <em>AppDomain</em>. Unfortunately, assemblies loaded by MEF are not available for this compilation process&hellip; I went ahead and checked with <a href="http://www.red-gate.com/products/reflector/" target="_blank">Reflector</a> if we could do something about this on ASP.NET side: nope. The main classes we need for this are internal :-( The MEF side could be easily tweaked since its source code is available on <a href="http://mef.codeplex.com" target="_blank">CodePlex</a>, but&hellip; it&rsquo;s still subject to change and will be included in .NET 4.0 as a framework component, which would limit my customizations a bit for the future.</p>
<p>Now let&rsquo;s describe this problem as one, simple sentence: we need the MEF plugin assembly loaded in our current <em>AppDomain</em>, available for all other components in the web application.</p>
<p>The solution to this: I want a MEF <em>DirectoryCatalog</em> to monitor my plugins folder and load/unload the assemblies in there dynamically. Loading should be no problem, but unloading&hellip; The assemblies will always be locked by my web server&rsquo;s process! So let&rsquo;s go for another approach: monitor the plugins folder, copy the new/modified assemblies to the web application&rsquo;s /bin folder and instruct MEF to load its exports from there. The solution: <em>WebServerDirectoryCatalog</em>. Here&rsquo;s the code:</p>
<p>[code:c#]</p>
<p>public sealed class WebServerDirectoryCatalog : ComposablePartCatalog <br />{ <br />&nbsp;&nbsp;&nbsp; private FileSystemWatcher fileSystemWatcher; <br />&nbsp;&nbsp;&nbsp; private DirectoryCatalog directoryCatalog; <br />&nbsp;&nbsp;&nbsp; private string path; <br />&nbsp;&nbsp;&nbsp; private string extension;</p>
<p>&nbsp;&nbsp;&nbsp; public WebServerDirectoryCatalog(string path, string extension, string modulePattern) <br />&nbsp;&nbsp;&nbsp; { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Initialize(path, extension, modulePattern); <br />&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; private void Initialize(string path, string extension, string modulePattern) <br />&nbsp;&nbsp;&nbsp; { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.path = path; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.extension = extension;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileSystemWatcher = new FileSystemWatcher(path, modulePattern); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileSystemWatcher.Changed += new FileSystemEventHandler(fileSystemWatcher_Changed); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileSystemWatcher.Created += new FileSystemEventHandler(fileSystemWatcher_Created); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileSystemWatcher.Deleted += new FileSystemEventHandler(fileSystemWatcher_Deleted); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileSystemWatcher.Renamed += new RenamedEventHandler(fileSystemWatcher_Renamed); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileSystemWatcher.IncludeSubdirectories = false; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileSystemWatcher.EnableRaisingEvents = true;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Refresh(); <br />&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; void fileSystemWatcher_Renamed(object sender, RenamedEventArgs e) <br />&nbsp;&nbsp;&nbsp; { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RemoveFromBin(e.OldName); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Refresh(); <br />&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; void fileSystemWatcher_Deleted(object sender, FileSystemEventArgs e) <br />&nbsp;&nbsp;&nbsp; { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RemoveFromBin(e.Name); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Refresh(); <br />&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; void fileSystemWatcher_Created(object sender, FileSystemEventArgs e) <br />&nbsp;&nbsp;&nbsp; { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Refresh(); <br />&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; void fileSystemWatcher_Changed(object sender, FileSystemEventArgs e) <br />&nbsp;&nbsp;&nbsp; { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Refresh(); <br />&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; private void Refresh() <br />&nbsp;&nbsp;&nbsp; { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Determine /bin path
<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string binPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "bin");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Copy files to /bin
<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (string file in Directory.GetFiles(path, extension, SearchOption.TopDirectoryOnly)) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; File.Copy(file, Path.Combine(binPath, Path.GetFileName(file)), true); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Not that big deal... Blog readers will probably kill me for this bit of code :-)
<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Create new directory catalog
<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; directoryCatalog = new DirectoryCatalog(binPath, extension); <br />&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; public override IQueryable&lt;ComposablePartDefinition&gt; Parts <br />&nbsp;&nbsp;&nbsp; { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return directoryCatalog.Parts; } <br />&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; private void RemoveFromBin(string name) <br />&nbsp;&nbsp;&nbsp; { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string binPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "bin"); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; File.Delete(Path.Combine(binPath, name)); <br />&nbsp;&nbsp;&nbsp; } <br />}</p>
<p>[/code]</p>
<h2>Download the example code</h2>
<p>First of all: this was tricky, and the solution to it is also a bit tricky. <strong><span style="text-decoration: underline;">Use at your own risk!</span></strong></p>
<p>You can download the example code here: <a href="/files/2009/6/RevisedMvcMefDemo.zip">RevisedMvcMefDemo.zip (1.03 mb)</a></p>
<p><a href="http://www.dotnetkicks.com/kick/?url=/post/2009/06/17/Revised-ASPNET-MVC-and-the-Managed-Extensibility-Framework-(MEF).aspx&amp;title=Revised: ASP.NET MVC and the Managed Extensibility Framework (MEF)"><img src="http://www.dotnetkicks.com/Services/Images/KickItImageGenerator.ashx?url=/post/2009/06/17/Revised-ASPNET-MVC-and-the-Managed-Extensibility-Framework-(MEF).aspx" border="0" alt="kick it on DotNetKicks.com" /> </a></p>
{% include imported_disclaimer.html %}
