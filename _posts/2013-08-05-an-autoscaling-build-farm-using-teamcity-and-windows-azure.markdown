---
layout: post
title: "An autoscaling build farm using TeamCity and Windows Azure"
date: 2013-08-05 08:52:00 +0000
comments: true
published: true
categories: ["post"]
tags: ["Azure", "General", "Projects", "Scalability", "Software", "Source control", "Webfarm"]
alias: ["/post/2013/08/05/An-autoscaling-build-farm-using-TeamCity-and-Windows-Azure.aspx", "/post/2013/08/05/an-autoscaling-build-farm-using-teamcity-and-windows-azure.aspx"]
author: Maarten Balliauw
redirect_from:
 - /post/2013/08/05/An-autoscaling-build-farm-using-TeamCity-and-Windows-Azure.aspx.html
 - /post/2013/08/05/an-autoscaling-build-farm-using-teamcity-and-windows-azure.aspx.html
---
<div style="padding: 4px; border-left-color: navy; border-left-width: 4px; border-left-style: solid; background-color: rgb(238, 238, 238);"><a href="/images/Untitled.gif"><img width="240" height="180" title="Autoscaling... myself!" align="right" style="margin: 5px 0px 5px 5px; float: right; display: inline;" alt="Autoscaling... myself!" src="/images/Untitled_thumb.gif"></a><strong>NOTE:</strong> While the content is this blog post will still work, JetBrains now has a plugin that is the recommended way of working with TeamCity and build agents on Azure. Please check <a href="http://blog.jetbrains.com/teamcity/2014/11/introducing-teamcity-azure-plugin-run-builds-in-the-cloud/" target="_blank">this blog post</a> to learn more about it.</div><p><br></p><p>Cloud computing is often referred to as a cost saver due to its billing models. If we can move workloads that are seasonal to the cloud, cost reduction is something that will come. No matter if it’s really “seasonal seasonal” (e.g. a temporary high workload around the holidays) or “daily seasonal” where workloads are different depending on the time of day, these workloads have written cloud all over them.</p>  <p>A workload that may be seasonal is the workload done by build servers. Take TeamCity for example. A TeamCity server instruments a pool of build agents that are either idle or compiling source code into binaries. Depending on how your team is structured and when people work, there is a big chance that pool of build agents is doing nothing for several hours every day, except incurring cost. What if we could move the build agents to a platform like Windows Azure and have them autoscale, depending on the actual load on the build farm?</p>  <h2>Creating a build agent virtual machine</h2>  <p>The first step in setting this brilliant scheme in motion is to set up a build agent virtual machine. We can select any virtual machine image we want for our build agent, even upload our own vhd’s if needed. I'm selecting a Windows Server 2012 image here but if you need a different OS for your build agent you can select that instead.</p>  <p>During the creation of this build agent, there is nothing special we should do. We can select a small/medium/large/extra large instance, give ourselves an administrator password and so on. The only important step here is that we set up an endpoint for the TeamCity build agent, listening on TCP port 9090.</p>  <p><a href="/images/image_301.png"><img width="579" height="229" title="Open load balancer endpoint" style="border: 0px currentColor; border-image: none; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="Open load balancer endpoint" src="/images/image_thumb_262.png" border="0"></a></p>  <p>Once the machine is started, we will have to install all required prerequisites for our build agent. We can connect using remote desktop (or SSH if it’s a Linux machine). On the machine I have here, I installed all .NET framework versions to ensure I'm able to build .NET projects. On a build machine for Java, we would install the correct runtimes and JDK's for our projects. Anything, really, if it is needed for the sources we’ll be building. On Windows, I typically use <a href="http://www.microsoft.com/web">Web Platform Installer</a> and <a href="http://www.chocolatey.org">Chocolatey</a> to get this done as automated as possible.</p>  <p><a href="/images/04.png"><img width="619" height="480" title="Web Platform Installer in action" style="border: 0px currentColor; border-image: none; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="Web Platform Installer in action" src="/images/04_thumb.png" border="0"></a></p>  <h2></h2>  <h2>Installing TeamCity build agent</h2>  <p>In order for our build agent to communicate with the TeamCity server, we have to install the build agent. We can do this by navigating to our TeamCity server from within the virtual machine and use the <em>Install Build Agents</em> link from the <em>Agents</em> page.</p>  <p><a href="/images/05.png"><img width="619" height="480" title="Installing build agent" style="border: 0px currentColor; border-image: none; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="Installing build agent" src="/images/05_thumb.png" border="0"></a></p>  <p>On a Windows server, we can use the Windows Installer but we can also use Java Web Start or even simply extract a ZIP file. This last option can be useful on a Linux machine, for example.</p>  <p>Installing the build agent is pretty much a <em>next, next, finish</em> operation. The only important thing is that we run the agent as a Windows service (or have it automatically start at boot time on other operating systems). We also want to specify the URL to our TeamCity server as well as the port on which the build agent will listen for incoming data from TeamCity. Note that this port should be the one opened in the load balancer earlier, in the case of this machine port 9090.</p>  <p><a href="/images/06.png"><img width="619" height="480" title="Specify port and server" style="border: 0px currentColor; border-image: none; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="Specify port and server" src="/images/06_thumb.png" border="0"></a></p>  <p>Before starting the build agent, make sure the local firewall allows incoming connections. Through the Windows firewall, allow incoming connections for port 9090 (and while we’re at it, for a range of ports so we can easily clone this machine and not care about the firewall anymore).</p>  <p><a href="/images/07.png"><img width="619" height="480" title="Windows Firewall configuration" style="border: 0px currentColor; border-image: none; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="Windows Firewall configuration" src="/images/07_thumb.png" border="0"></a></p>  <p>If we now start the build agent service, it should connect to our TeamCity server. Under the agents tab, we should be seeing a new unauthorized agent popping up. If that works, we’re good to go with our build agent farm.</p>  <p><a href="/images/08.png"><img width="640" height="428" title="A new unauthorized build agent shows up" style="border: 0px currentColor; border-image: none; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="A new unauthorized build agent shows up" src="/images/08_thumb.png" border="0"></a></p>  <p>Don’t shut down the machine just yet, we still need to prepare it for creating a build agent image.</p>  <h2>Creating a build agent image</h2>  <p>While still connected through remote desktop, open a command prompt and run the <em>sysprep /generalize</em> command from the <em>c:\windows\system32\sysprep</em> folder. On Linux, there’s a similar option in the <a href="https://www.windowsazure.com/en-us/manage/windows/how-to-guides/capture-an-image/">Windows Azure agent</a>. Sysprep ensures the machine can be cloned into a new machine, getting its own settings like a hostname and IP address. A non-sysprepped machine can thus never be cloned.</p>  <p><a href="/images/09.png"><img width="619" height="480" title="Sysprep our machine" style="border: 0px currentColor; border-image: none; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="Sysprep our machine" src="/images/09_thumb.png" border="0"></a></p>  <p>Once finished, our RDP connection should be gone and our machine can be shutdown in the Windows Azure Management Portal. In fact, it <em>must</em> be shut down. Once that is done, we can use the <em>Capture</em> button and transform our virtual machine into a template we can create new virtual machines from.<a href="/images/image_302.png"><img width="467" height="480" title="Capturing a virtual machine image" style="border: 0px currentColor; border-image: none; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="Capturing a virtual machine image" src="/images/image_thumb_263.png" border="0"></a></p>  <p>The capturing process will take a couple of minutes and results in having no more build server virtual machine to be found in the Windows Azure Management Portal. Is that bad? No, we can now start cloning the machine and create multiple, all having the exact same configuration and components installed.</p>  <h2>Setting up multiple build agent machines</h2>  <p>The next thing we want to have is multiple build agent machines. From the Windows Azure Management portal, we can create them. Not based on a platform image but using the image created during the previous step. </p>  <p><a href="/images/image_303.png"><img width="640" height="405" title="Using a virtual machine image as the base" style="border: 0px currentColor; border-image: none; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="Using a virtual machine image as the base" src="/images/image_thumb_264.png" border="0"></a></p>  <p>The virtual machine configuration can be whatever we want. Do we want extra small instances or extra large? It’s all up to us and our credit card. On the next page, we have to specify some more important details. First, we have to select or create a cloud service. This will be the DNS host name under which all of our build agents are going to live. We also have to specify the affinity group, in essence a setting telling Windows Azure to never unplug power or networking for all machines in this group at the same time.</p>  <p><a href="/images/image_304.png"><img width="640" height="404" title="image" style="border: 0px currentColor; border-image: none; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="Selecting cloud service and availability set" src="/images/image_thumb_265.png" border="0"></a></p>  <p>We will be creating a couple of machines, so it’s important to get the next page right. Since all our machines will share the same hostname and IP address to the outside world, our build agents have to listen on different TCP ports. Make sure that the first agent maps port 9090 to port 9090, the second one 9091 to 9091 and so on. Not doing this will mess with your mind afterwards when troubleshooting.</p>  <p><a href="/images/image_305.png"><img width="640" height="406" title="Endpoint configuration" style="border: 0px currentColor; border-image: none; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="Endpoint configuration" src="/images/image_thumb_266.png" border="0"></a></p>  <p>Finish the process, let Windows Azure start the machine and create a new one. Important: same cloud service, same availability set and correct endpoint mappings!</p>  <h2>Configuring the build agents</h2>  <p>Once we have several machines running, we have to connect to them using remote desktop again. This can be done through the portal. Once in, locate the build agent configuration file (<em>c:\BuildAgent\conf\buildAgent.properties </em>in a default installation) and set the port number on which it listens to the one that was mapped as an external endpoint. Again, agent one will listen on port 9090, agent number two on 9091 and so on. We can also set a better name for the build agent, in my case I’ve chosen to go with “agent2”. Very inspirational and all.</p>  <p><a href="/images/image_306.png"><img width="640" height="360" title="Setting build agent name and port" style="border: 0px currentColor; border-image: none; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="Setting build agent name and port" src="/images/image_thumb_267.png" border="0"></a></p>  <p>Save and restart the build agent (or the machine). The TeamCity server should now start listing all build agents.</p>  <p><a href="/images/17_1.png"><img width="640" height="428" title="Windows Azure build agents for TeamCity" style="border: 0px currentColor; border-image: none; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="Windows Azure build agents for TeamCity" src="/images/17_thumb_1.png" border="0"></a></p>  <p>Make sure to authorize them all, as we want to be sure they can connect to TeamCity server later on. Once that has been done and all build agents are listed here, we can shut them all down except for one. We want to have something running, right?</p>  <h2>Configuring autoscaling</h2>  <p>It might have been a good question: why did we have to move all these machines under the same cloud service? The reason is simple: we wanted to autoscale our farm and this can only be done within one cloud service. From the cloud service, click the <em>Scale </em>tab and start configuring.</p>  <p><a href="/images/18_1.png"><img width="1024" height="685" title="Autoscaling configuration" style="border: 0px currentColor; border-image: none; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="Autoscaling configuration" src="/images/18_thumb_1.png" border="0"></a></p>  <p>For this post, I’ve chosen the following values:</p>  <ul>   <li>Autoscale based on <strong>CPU</strong></li>    <li>Have a minimum of <strong>one</strong> instance, and a maximum of, well… all of them.</li>    <li>The target CPU range is <strong>0 to 10</strong>. For a production environment this will typically be between <strong>60 and 80</strong> or <strong>40 and 80</strong>, depending on the chosen machine size for the build agents. Windows Azure will trigger an autoscaling operation if we go outside this range, having a small and low range means it will trigger a scale operation much faster. Bigger numbers means slower to respond.</li>    <li>Scale up by and scale down by as well as the number of minutes to wait after the previous operations are up to you. If you want a build agent to remain online for 30 minutes after it has been started, even if CPU usage drops, set it to 30 minutes. If 2 machines should be started at once, increase that number as well.</li> </ul>  <p>Scaling will happen based on the average CPU percentage of all running machines. If our builds run at 100% CPU all the time on our agent we can set the thresholds a bit higher. If builds are only taking 20% we might want to run multiple agents on one machine or decrease the scaling thresholds a bit. Want to measure CPU utilization for a given build? Better read up on the <a href="http://blogs.jetbrains.com/teamcity/2013/02/11/teamcity-performance-monitor/">TeamCity Performance Monitor</a> then.</p>  <h2>Putting it to the test</h2>  <p>Putting it to the test shouldn’t be that hard. Start some builds and make sure the agent gets loaded with builds. Once we hit the CPU threshold, Windows Azure will launch a virtual machine that was previously turned off.</p>  <p><a href="/images/22.png"><img width="640" height="428" title="Windows Azure autoscaling in action" style="border: 0px currentColor; border-image: none; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="Windows Azure autoscaling in action" src="/images/22_thumb.png" border="0"></a></p>  <p>Once it has booted, we will also see it surface on the TeamCity server.</p>  <p><a href="/images/23.png"><img width="640" height="428" title="Build agents on TeamCity" style="border: 0px currentColor; border-image: none; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" alt="Build agents on TeamCity" src="/images/23_thumb.png" border="0"></a></p>  <p>Once the load goes down again, Windows Azure will shutdown machines that are below the thresholds and make sure they don’t incur costs any longer. Which is pretty impressive! </p>  <p>If a development team triggers a massive amount of builds during the day, Windows Azure will pretty soon scale out to a higher number of virtual build agents. And at night when there are only some builds being triggered, it will scale back to lesser instances. If, for example, we manage to run machines only for 12 hours instead of 24 hours a day, that means our build farm’s price goes down by half.</p>  <p>TeamCity’s architecture as well as the way Windows Azure works makes this cost reduction possible. It’s also fun to set up, it gives us a wide range of options (how about a Windows Server 2012 farm, a Linux farm and so on).</p>  <p>Enjoy!</p>
{% include imported_disclaimer.html %}
